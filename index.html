<!DOCTYPE html>
<html>
<head>
  <title>Checkpoint Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(to bottom, #0077ff, #001f4d);
      display: flex;
      flex-direction: column;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    
    #notifBar {
      background: rgba(255,255,255,0.95);
      padding: 12px;
      text-align: center;
      font-weight: bold;
      color: #001f4d;
      border-bottom: 2px solid #0077ff;
      font-size: 14px;
      min-height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #map {
      flex: 1;
      position: relative;
    }

    /* Dashboard Sidebar */
    #dashboardToggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 119, 255, 0.9);
      color: white;
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 6px 20px rgba(0,0,0,0.25);
      z-index: 1002;
    }

    #dashboardToggle:hover {
      background: rgba(0, 86, 204, 0.95);
    }

    #sidebar {
      position: fixed;
      top: 0;
      right: -420px;
      width: 400px;
      height: 100vh;
      background: linear-gradient(140deg, #001f4d 0%, #002f5d 45%, #005c89 100%);
      border-left: 3px solid #00bfff;
      transition: right 0.32s ease-in-out;
      padding: 24px;
      display: flex;
      flex-direction: column;
      box-shadow: -8px 0 28px rgba(0,32,64,0.35);
      z-index: 1001;
      color: #e0f7fa;
    }

    #sidebar.open {
      right: 0;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .sidebar-title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    #closeDashboard {
      background: transparent;
      border: none;
      color: #7acaff;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 8px;
    }

    #closeDashboard:hover {
      background: rgba(0, 119, 255, 0.2);
      color: #e0f7fa;
    }

    #sidebarNav {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .nav-item {
      flex: 1 1 calc(50% - 8px);
      background: rgba(0, 68, 119, 0.6);
      border: 1px solid rgba(0, 191, 255, 0.35);
      color: #cfe9ff;
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .nav-item:hover {
      background: rgba(0, 119, 255, 0.65);
      transform: translateY(-1px);
    }

    .nav-item.active {
      background: rgba(0, 191, 255, 0.85);
      color: #002345;
      box-shadow: 0 4px 14px rgba(0, 64, 128, 0.35);
    }

    #sidebarSections {
      flex: 1;
      overflow-y: auto;
      padding-right: 6px;
    }

    .sidebar-section {
      display: none;
      animation: fadeIn 0.25s ease;
    }

    .sidebar-section.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .section-heading {
      font-size: 17px;
      font-weight: 600;
      letter-spacing: 0.5px;
      color: #7bd5ff;
      margin-bottom: 12px;
    }

    .account-card {
      background: rgba(0,32,64,0.7);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 2px 10px rgba(0,32,64,0.2);
      font-size: 15px;
    }

    .status-card {
      background: linear-gradient(90deg, #003366 40%, #005580 100%);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel {
      background: rgba(0, 32, 64, 0.6);
      border-radius: 12px;
      padding: 14px 16px;
      margin-bottom: 16px;
      box-shadow: 0 3px 15px rgba(0, 24, 48, 0.25);
    }

    .panel:last-child {
      margin-bottom: 0;
    }

    .hidden {
      display: none !important;
    }

    .panel label {
      font-size: 13px;
      color: #9ddcff;
    }

    .device-top-location {
      margin-top: 6px;
      font-size: 12px;
      color: #0b2a4e;
    }

    .top-location-badge {
      margin-top: 8px;
      padding: 8px 10px;
      background: rgba(255,255,255,0.92);
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      color: #0b2a4e;
      font-size: 13px;
    }

    .top-location-badge strong {
      color: #002c58;
    }

    .reminder-item {
      padding: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      margin-bottom: 8px;
      background: rgba(0, 48, 84, 0.55);
    }

    .device-item {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .device-info {
      flex: 1;
    }
    
    .device-id {
      font-weight: bold;
      color: #0077ff;
      font-size: 16px;
    }
    
    .device-coords {
      color: #666;
      font-size: 14px;
      margin-top: 4px;
    }
    
    .device-time {
      color: #999;
      font-size: 12px;
      margin-top: 2px;
    }
    
    .current-device {
      background: #e3f2fd;
      border-color: #0077ff;
    }

    /* Login */
    #loginBox {
      position: absolute;
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0px 8px 25px rgba(0,0,0,0.3);
      width: 90%;
      max-width: 350px;
    }
    
    #loginBox h3 {
      text-align: center;
      color: #001f4d;
      margin-bottom: 25px;
      font-size: 24px;
    }
    
    #loginBox input {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border: 2px solid #e1e1e1;
      border-radius: 8px;
      font-size: 16px;
      box-sizing: border-box;
    }
    
    #loginBox input:focus {
      border-color: #0077ff;
      outline: none;
    }
    
    #loginBtn {
      width: 100%;
      padding: 12px;
      background: #0077ff;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 10px;
    }
    
    #loginBtn:hover {
      background: #0056cc;
    }
    
    .auth-switch {
      text-align: center;
      margin-top: 15px;
      color: #666;
    }
    
    #switchModeBtn {
      background: none;
      border: none;
      color: #0077ff;
      cursor: pointer;
      text-decoration: underline;
      font-size: 14px;
      margin-left: 5px;
    }
    
    #switchModeBtn:hover {
      color: #0056cc;
    }
    
    #logoutBtn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 15px;
    }
    
    #logoutBtn:hover {
      background: #c82333;
    }
    
    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #28a745;
      display: inline-block;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .error-message {
      color: #dc3545;
      text-align: center;
      margin-top: 10px;
      font-size: 14px;
    }
    
    .loading {
      text-align: center;
      color: #666;
      padding: 20px;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="manifest" href="/manifest.json">
</head>
<body>
  <div id="notifBar">
    <span class="status-indicator"></span>
    <span id="notifText">Welcome to Checkpoint Tracker - Connecting...</span>
    <button id="enableNotifBtn" style="margin-left:12px;padding:6px 10px;border-radius:6px;background:#00bfff;color:white;border:none;cursor:pointer;font-weight:bold;">Enable notifications</button>
  </div>
  <!-- Reminder HUD -->
  <div id="reminderHUD" style="position:fixed;left:50%;top:18%;transform:translateX(-50%);background:linear-gradient(90deg,#ffffff,#e6f7ff);color:#001f4d;padding:18px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.25);z-index:2000;display:none;min-width:300px;max-width:90%;">
    <div id="reminderHUDText" style="font-weight:bold;margin-bottom:8px;"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button id="snoozeBtn" style="background:#ffc107;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:bold;">Snooze 5m</button>
      <button id="dismissBtn" style="background:#28a745;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;color:white;font-weight:bold;">Dismiss</button>
    </div>
  </div>
  <div id="map"></div>

  <button id="dashboardToggle">‚ò∞ Dashboard</button>
  <aside id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">Checkpoint Dashboard</div>
      <button id="closeDashboard" aria-label="Close dashboard">‚úï</button>
    </div>
    <nav id="sidebarNav">
      <button class="nav-item active" data-section="overview">Overview</button>
      <button class="nav-item" data-section="devices">Tracked Devices</button>
      <button class="nav-item" data-section="reminders">Reminders</button>
      <button class="nav-item" data-section="settings">Settings</button>
    </nav>
    <div id="sidebarSections">
      <section id="section-overview" class="sidebar-section active">
        <div class="section-heading">Account</div>
        <div class="account-card" id="accountInfo">
          <div><strong>User:</strong> <span id="accountName">-</span></div>
          <div><strong>Email:</strong> <span id="accountEmail">-</span></div>
        </div>
        <div class="panel" id="userLocationPanel">
          <div style="font-weight:600;color:#0056cc;margin-bottom:6px;">Your latest location</div>
          <div id="userLocationCoords" style="color:#d7ecff;font-size:14px;">Waiting for device updates...</div>
          <div id="userLocationTime" style="color:#375b7a;font-size:12px;margin-top:4px;">-</div>
        </div>
        <div class="status-card" id="sidebarNotifBar">
          <span class="status-indicator"></span>
          Welcome to Checkpoint Tracker
        </div>
      </section>

      <section id="section-devices" class="sidebar-section">
        <div class="section-heading">Tracked Devices</div>
        <div id="linkChildBox" class="panel">
          <label for="linkChildEmail" style="display:block;font-size:13px;color:#9ddcff;margin-bottom:6px;">Link a child's account</label>
          <div style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;">
            <input type="email" id="linkChildEmail" placeholder="Child's email" style="flex:1;min-width:160px;padding:9px;border-radius:8px;border:1px solid rgba(0,191,255,0.4);background:rgba(0,32,64,0.8);color:#e0f7fa;">
            <button id="linkChildBtn" style="background:#00bfff;color:white;border:none;border-radius:8px;padding:9px 14px;font-weight:bold;cursor:pointer;">Link Child</button>
          </div>
          <div id="linkChildMsg" style="color:#8dd8ff;font-size:13px;margin-top:4px;"></div>
        </div>
        <div id="linkedDevicesContainer" style="margin-bottom:16px;"></div>

        <div id="aiSummaryBox" class="panel">
          <div class="section-heading" style="margin-bottom:8px;">AI Location Summary</div>
          <div id="aiKeyControls">
            <input type="password" id="aiApiKeyInput" placeholder="OpenAI API key (kept in this browser)" style="width:100%;padding:8px;border-radius:6px;border:1px solid rgba(0,191,255,0.4);background:rgba(0,32,64,0.8);color:#e0f7fa;margin-bottom:8px;">
            <div style="display:flex;gap:6px;margin-bottom:8px;flex-wrap:wrap;">
              <button id="toggleAiKeyBtn" type="button" style="flex:0 0 auto;background:#225c86;color:#e0f7fa;border:none;border-radius:6px;padding:6px 10px;font-weight:bold;cursor:pointer;">Show</button>
              <button id="saveAiKeyBtn" type="button" style="flex:1;background:#00bfff;color:white;border:none;border-radius:6px;padding:6px 10px;font-weight:bold;cursor:pointer;min-width:140px;">Save key locally</button>
              <button id="clearAiKeyBtn" type="button" style="flex:0 0 auto;background:#dc3545;color:white;border:none;border-radius:6px;padding:6px 10px;font-weight:bold;cursor:pointer;">Clear</button>
            </div>
          </div>
          <button id="generateAiSummaryBtn" style="width:100%;background:#28a745;color:white;border:none;border-radius:6px;padding:8px 12px;font-weight:bold;cursor:pointer;margin-bottom:8px;">Generate summary</button>
          <div id="aiSummaryStatus" style="color:#cfe9ff;font-size:13px;margin-bottom:6px;">AI summary is idle.</div>
          <div id="aiSummaryOutput" style="background:rgba(0,32,64,0.6);border-radius:6px;padding:10px;color:#e0f7fa;font-size:14px;min-height:48px;white-space:pre-wrap;">Add linked devices and run the AI summarizer to see a narrative.</div>
          <div id="aiSummaryHint" style="margin-top:6px;color:#7fb9d6;font-size:12px;line-height:1.4;">Keys are stored in this browser's local storage. Avoid using shared devices.</div>
        </div>

        <div id="deviceList" class="panel">
          <div class="loading">Loading devices...</div>
        </div>
        <div id="deviceDetails" class="panel hidden"></div>
      </section>

      <section id="section-reminders" class="sidebar-section">
        <div class="section-heading">Reminders</div>
        <div id="reminderBox" class="panel">
          <input type="text" id="reminderNote" placeholder="Reminder note" style="width:100%;padding:9px;border-radius:8px;border:1px solid rgba(0,191,255,0.4);background:rgba(0,32,64,0.8);color:#e0f7fa;margin-bottom:8px;">
          <input type="datetime-local" id="reminderTime" style="width:100%;padding:9px;border-radius:8px;border:1px solid rgba(0,191,255,0.4);background:rgba(0,32,64,0.8);color:#e0f7fa;margin-bottom:8px;">
          <button id="addReminderBtn" style="width:100%;background:#00bfff;color:white;border:none;border-radius:8px;padding:9px 12px;font-weight:bold;cursor:pointer;">Add Reminder</button>
          <div id="reminderMsg" style="color:#8dd8ff;margin-top:6px;font-size:13px;"></div>
        </div>
        <div class="panel" style="margin-bottom:16px;">
          <label for="reminderDatePicker" style="display:block;font-size:13px;color:#9ddcff;margin-bottom:6px;">Browse reminders by day</label>
          <input type="date" id="reminderDatePicker" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(0,191,255,0.4);background:rgba(0,32,64,0.8);color:#e0f7fa;margin-bottom:10px;">
          <div id="reminderDateNotes" style="color:#cfe9ff;font-size:13px;min-height:40px;white-space:pre-line;">Select a date to see notes.</div>
        </div>
        <div id="reminderList" class="panel" style="color:#e0f7fa;"></div>
      </section>

      <section id="section-settings" class="sidebar-section">
        <div class="section-heading">Settings</div>
        <div class="panel">
          <div style="margin-bottom:12px;font-size:14px;color:#d1ecff;">Manage your session and review notification status from the top banner.</div>
          <button id="logoutBtn" style="background:#dc3545;color:white;border:none;border-radius:8px;padding:10px 14px;font-weight:bold;cursor:pointer;width:100%;">Logout</button>
        </div>
      </section>
    </div>
  </aside>

  <!-- Login/Register -->
  <div id="loginBox">
    <h3 id="authTitle">üîê Login</h3>
    <input type="text" id="displayName" placeholder="Enter your name" style="display: none;">
    <input type="email" id="email" placeholder="Enter your email">
    <input type="password" id="password" placeholder="Enter your password">
    <input type="password" id="confirmPassword" placeholder="Confirm your password" style="display: none;">
    <button id="loginBtn">Login</button>
    <div class="auth-switch">
      <span id="switchText">Don't have an account?</span>
      <button id="switchModeBtn" type="button">Register</button>
    </div>
    <div id="errorMessage" class="error-message"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, get, update, onValue, serverTimestamp, query, limitToLast } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyAK020UjQmGU1FJVsH7ecmnPy9sNTUn0Qo",
      authDomain: "checkpoint-d7a4c.firebaseapp.com",
      databaseURL: "https://checkpoint-d7a4c-default-rtdb.firebaseio.com",
      projectId: "checkpoint-d7a4c",
      storageBucket: "checkpoint-d7a4c.appspot.com",
      messagingSenderId: "187939004352",
      appId: "1:187939004352:web:82baf19ca3cf6b3ddd7225",
      measurementId: "G-F9FPNJ44H8"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);
  const AI_SUMMARY_ENDPOINT = "https://falling-frog-066e.biatingoc-sydney11.workers.dev/"; // Cloudflare Worker proxy for AI summaries

    // DOM elements
    const loginBox = document.getElementById("loginBox");
    const mapDiv = document.getElementById("map");
    const notifBar = document.getElementById("notifBar");
  const errorMessage = document.getElementById("errorMessage");
  const sidebarNotifBar = document.getElementById("sidebarNotifBar");
  const accountName = document.getElementById("accountName");
  const accountEmail = document.getElementById("accountEmail");
  const aiKeyControls = document.getElementById("aiKeyControls");
  const aiSummaryHint = document.getElementById("aiSummaryHint");
  const aiApiKeyInput = document.getElementById("aiApiKeyInput");
  const toggleAiKeyBtn = document.getElementById("toggleAiKeyBtn");
  const saveAiKeyBtn = document.getElementById("saveAiKeyBtn");
  const clearAiKeyBtn = document.getElementById("clearAiKeyBtn");
  const generateAiSummaryBtn = document.getElementById("generateAiSummaryBtn");
  const aiSummaryStatus = document.getElementById("aiSummaryStatus");
  const aiSummaryOutput = document.getElementById("aiSummaryOutput");
  const userLocationPanel = document.getElementById("userLocationPanel");
  const userLocationCoords = document.getElementById("userLocationCoords");
  const userLocationTime = document.getElementById("userLocationTime");
  const reminderDatePicker = document.getElementById("reminderDatePicker");
  const reminderDateNotes = document.getElementById("reminderDateNotes");
    
  let map, deviceId, userEmail, userName;
    const markers = {};
    let watchId;
    let isRegisterMode = false;
  const AI_KEY_STORAGE = "checkpoint_ai_api_key_v1";
  let lastHistoryEntry = null;
  const HISTORY_MIN_INTERVAL_MS = 5 * 60 * 1000;
  const HISTORY_MIN_DISTANCE_KM = 0.1;
  let remindersCache = [];


    // Dashboard toggle and navigation
    const sidebar = document.getElementById("sidebar");
    const toggleDashboardBtn = document.getElementById("dashboardToggle");
    const closeDashboardBtn = document.getElementById("closeDashboard");
    const navButtons = Array.from(document.querySelectorAll("#sidebarNav .nav-item"));

    function openDashboard() {
      sidebar.classList.add("open");
      if (toggleDashboardBtn) {
        toggleDashboardBtn.textContent = "Close Dashboard";
      }
    }

    function closeDashboard() {
      sidebar.classList.remove("open");
      if (toggleDashboardBtn) {
        toggleDashboardBtn.textContent = "‚ò∞ Dashboard";
      }
    }

    if (toggleDashboardBtn) {
      toggleDashboardBtn.addEventListener("click", () => {
        if (sidebar.classList.contains("open")) {
          closeDashboard();
        } else {
          openDashboard();
        }
      });
    }

    if (closeDashboardBtn) {
      closeDashboardBtn.addEventListener("click", () => {
        closeDashboard();
      });
    }

    function activateSection(sectionName) {
      navButtons.forEach(btn => {
        const isActive = btn.dataset.section === sectionName;
        btn.classList.toggle("active", isActive);
      });
      document.querySelectorAll(".sidebar-section").forEach(section => {
        section.classList.toggle("active", section.id === `section-${sectionName}`);
      });
    }

    if (navButtons.length) {
      const initial = (navButtons.find(btn => btn.classList.contains("active")) || navButtons[0]).dataset.section;
      if (initial) {
        activateSection(initial);
      }
    }

    navButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const target = btn.dataset.section;
        if (target) {
          activateSection(target);
        }
      });
    });

    // Link Child button handler
    const linkChildBtn = document.getElementById("linkChildBtn");
    const linkChildEmailInput = document.getElementById("linkChildEmail");
    const linkChildMsg = document.getElementById("linkChildMsg");

  // Linked devices list container (defined in markup)
  const linkedDevicesContainer = document.getElementById("linkedDevicesContainer");

    // Function to refresh linked devices list
    // Track attached child listeners to avoid duplicates
    const watchedChildren = new Map();
    async function refreshLinkedDevices() {
      if (!deviceId || !linkedDevicesContainer) return;
      const linksRef = ref(db, `links/${deviceId}`);
      onValue(linksRef, async (snapshot) => {
        const links = snapshot.val() || {};
        linkedDevicesContainer.innerHTML = "";
        
        // Remove listeners for children that are no longer linked
        Array.from(watchedChildren.keys()).forEach(childId => {
          if (!links[childId]) {
            const unsubscribe = watchedChildren.get(childId);
            if (typeof unsubscribe === 'function') {
              unsubscribe();
            }
            watchedChildren.delete(childId);
          }
        });

        for (const childId in links) {
          const deviceRef = ref(db, `devices/${childId}`);
          const deviceSnapshot = await get(deviceRef);
          const childDevice = deviceSnapshot.val();

          if (childDevice) {
            const deviceDiv = document.createElement("div");
            deviceDiv.style.background = "rgba(0,115,255,0.1)";
            deviceDiv.style.padding = "8px";
            deviceDiv.style.borderRadius = "6px";
            deviceDiv.style.marginBottom = "8px";
            deviceDiv.style.display = "flex";
            deviceDiv.style.justifyContent = "space-between";
            deviceDiv.style.alignItems = "center";
            
            const info = document.createElement("div");
            info.innerHTML = `
              <div style="color: #e0f7fa; font-weight: bold;">${childDevice.displayName || childDevice.email}</div>
              <div style="color: #00bfff; font-size: 12px;">${childDevice.email}</div>
            `;
            
            const unlinkBtn = document.createElement("button");
            unlinkBtn.textContent = "Unlink";
            unlinkBtn.style.background = "#dc3545";
            unlinkBtn.style.color = "white";
            unlinkBtn.style.border = "none";
            unlinkBtn.style.borderRadius = "4px";
            unlinkBtn.style.padding = "4px 8px";
            unlinkBtn.style.cursor = "pointer";
            
            unlinkBtn.onclick = () => unlinkChild(childId);
            
            deviceDiv.appendChild(info);
            deviceDiv.appendChild(unlinkBtn);
            linkedDevicesContainer.appendChild(deviceDiv);

            // Attach per-child device listener only once
            if (!watchedChildren.has(childId)) {
              const unsubscribe = onValue(deviceRef, (deviceSnapshot) => {
                const device = deviceSnapshot.val();
                if (device && device.lastSeen) {
                  checkDeviceLocation(childId, device);
                }
              });
              watchedChildren.set(childId, unsubscribe);
            }
          }
        }
      });
    }

    // Function to unlink a child device
    async function unlinkChild(childId) {
      try {
        await set(ref(db, `links/${deviceId}/${childId}`), null);
        await set(ref(db, `devices/${childId}/linkedTo`), null);
        refreshLinkedDevices();
      } catch (err) {
        linkChildMsg.textContent = "Error unlinking device: " + err.message;
      }
    }

    linkChildBtn.addEventListener("click", async () => {
      const childEmail = linkChildEmailInput.value.trim().toLowerCase();
      if (!childEmail) {
        linkChildMsg.textContent = "Please enter a child's email.";
        return;
      }
      linkChildBtn.textContent = "Linking...";
      linkChildBtn.disabled = true;
      linkChildMsg.textContent = "";
      
      try {
        // Get all devices from Firebase
        const devicesRef = ref(db, "devices");
        const snapshot = await get(devicesRef);
        const devices = snapshot.val();
        let foundChildId = null;

        for (const uid in devices) {
          if (devices[uid].email && devices[uid].email.toLowerCase() === childEmail) {
            foundChildId = uid;
            break;
          }
        }

        if (foundChildId) {
          console.log('Found child device:', foundChildId, 'for email:', childEmail);
          // Check if device is already linked
          const existingLinkRef = ref(db, `devices/${foundChildId}/linkedTo`);
          const existingLinkSnapshot = await get(existingLinkRef);
          
          if (existingLinkSnapshot.val()) {
            linkChildMsg.textContent = "This device is already linked to another parent.";
            linkChildMsg.style.color = "#ffc107";
          } else {
            // Save bidirectional link
            const updates = {
              [`links/${deviceId}/${foundChildId}`]: true,
              [`devices/${foundChildId}/linkedTo`]: deviceId
            };
            
            console.log('Creating link:', updates);
            await update(ref(db), updates);
            linkChildMsg.textContent = `‚úì Linked ${childEmail}! They must log in on their device and allow location for tracking to work.`;
            linkChildMsg.style.color = "#28a745";
            linkChildEmailInput.value = "";
            
            notifBar.innerHTML = `<span class="status-indicator" style="background:#28a745"></span>Linked ${childEmail} (UID: ${foundChildId.substring(0,8)}...) - waiting for their location updates`;
            refreshLinkedDevices();
          }
        } else {
          linkChildMsg.textContent = `No device found with email: ${childEmail}. They must create an account first!`;
          linkChildMsg.style.color = "#dc3545";
        }
      } catch (err) {
        linkChildMsg.textContent = "Error: " + err.message;
      }
      
      linkChildBtn.textContent = "Link Child";
      linkChildBtn.disabled = false;
    });

    if (toggleAiKeyBtn && aiApiKeyInput) {
      toggleAiKeyBtn.addEventListener("click", () => {
        const hidden = aiApiKeyInput.type === "password";
        aiApiKeyInput.type = hidden ? "text" : "password";
        toggleAiKeyBtn.textContent = hidden ? "Hide" : "Show";
      });
    }

    if (saveAiKeyBtn && aiApiKeyInput) {
      saveAiKeyBtn.addEventListener("click", () => {
        const key = aiApiKeyInput.value.trim();
        if (!key) {
          if (aiSummaryStatus) {
            aiSummaryStatus.textContent = "Enter a key before saving.";
          }
          return;
        }
        if (setStoredAiKey(key)) {
          if (aiSummaryStatus) {
            aiSummaryStatus.textContent = "Key saved locally.";
          }
        } else if (aiSummaryStatus) {
          aiSummaryStatus.textContent = "Unable to access local storage.";
        }
      });
    }

    if (clearAiKeyBtn && aiApiKeyInput) {
      clearAiKeyBtn.addEventListener("click", () => {
        aiApiKeyInput.value = "";
        if (clearStoredAiKey()) {
          if (aiSummaryStatus) {
            aiSummaryStatus.textContent = "Key cleared from this browser.";
          }
        } else if (aiSummaryStatus) {
          aiSummaryStatus.textContent = "Local storage unavailable.";
        }
      });
    }

    if (generateAiSummaryBtn) {
      generateAiSummaryBtn.addEventListener("click", () => {
        generateAiSummary();
      });
    }

    setupAiSummaryMode();

  // Note: linked devices are loaded after login in initMap to avoid registering listeners before deviceId is set

    // Auth mode switching
    document.getElementById("switchModeBtn").addEventListener("click", (e) => {
      e.preventDefault();
      toggleAuthMode();
    });

    // Login/Register button functionality
    document.getElementById("loginBtn").onclick = function(e) {
      e.preventDefault();
      if (isRegisterMode) {
        handleRegister();
      } else {
        handleLogin();
      }
    };

    function toggleAuthMode() {
      isRegisterMode = !isRegisterMode;
      const title = document.getElementById("authTitle");
      const loginBtn = document.getElementById("loginBtn");
      const switchText = document.getElementById("switchText");
      const switchBtn = document.getElementById("switchModeBtn");
      const displayNameField = document.getElementById("displayName");
      const confirmPasswordField = document.getElementById("confirmPassword");

      if (isRegisterMode) {
        title.textContent = "üìù Register";
        loginBtn.textContent = "Register";
        switchText.textContent = "Already have an account?";
        switchBtn.textContent = "Login";
        displayNameField.style.display = "block";
        confirmPasswordField.style.display = "block";
      } else {
        title.textContent = "üîê Login";
        loginBtn.textContent = "Login";
        switchText.textContent = "Don't have an account?";
        switchBtn.textContent = "Register";
        displayNameField.style.display = "none";
        confirmPasswordField.style.display = "none";
      }

      // Clear all input fields and error message when switching modes
      document.getElementById("email").value = "";
      document.getElementById("password").value = "";
      document.getElementById("confirmPassword").value = "";
      document.getElementById("displayName").value = "";
      errorMessage.textContent = "";
    }

    async function handleLogin() {
      const email = document.getElementById("email").value.trim();
      const password = document.getElementById("password").value;
      const loginBtn = document.getElementById("loginBtn");
      
      if (!email || !password) {
        showError("Please enter both email and password");
        return;
      }
      
      try {
        loginBtn.textContent = "Logging in...";
        loginBtn.disabled = true;
        
        // Attempt to sign in
        const userCredential = await signInWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;
        
        // Clear any error messages
        errorMessage.textContent = "";
        
        // Update UI immediately
        loginBox.style.display = "none";
        userEmail = user.email;
        userName = user.displayName || user.email.split('@')[0];
        accountName.textContent = userName;
        accountEmail.textContent = userEmail;
        
  // initMap will be called via onAuthStateChanged; no need to call it here
        
        // Update sidebar notification
        sidebarNotifBar.innerHTML = `<span class="status-indicator"></span>Logged in as: ${userName}`;
        
      } catch (err) {
        showError("Login failed: " + err.message);
        loginBtn.textContent = "Login";
        loginBtn.disabled = false;
      }
    }

    async function handleRegister() {
      const email = document.getElementById("email").value.trim();
      const password = document.getElementById("password").value;
      const confirmPassword = document.getElementById("confirmPassword").value;
      const name = document.getElementById("displayName").value.trim();
      const loginBtn = document.getElementById("loginBtn");
      
      if (!email || !password || !confirmPassword || !name) {
        showError("Please fill in all fields");
        return;
      }
      
      if (password !== confirmPassword) {
        showError("Passwords do not match");
        return;
      }
      
      if (password.length < 6) {
        showError("Password must be at least 6 characters long");
        return;
      }
      
      try {
        loginBtn.textContent = "Creating account...";
        loginBtn.disabled = true;
        
        // Create the user account
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;
        
        // Update the user's profile with their name
        await updateProfile(user, {
          displayName: name
        });
        
        // Clear any error messages
        errorMessage.textContent = "";
        
        // Initialize the user's data in the database
        await set(ref(db, `devices/${user.uid}`), {
          email: email,
          displayName: name,
          uid: user.uid,
          lastSeen: serverTimestamp()
        });
        
        // Switch back to login mode
        isRegisterMode = false;
        toggleAuthMode();
        
        // Auto-login after successful registration
        await signInWithEmailAndPassword(auth, email, password);
        
      } catch (err) {
        showError("Registration failed: " + err.message);
        loginBtn.textContent = "Register";
        loginBtn.disabled = false;
      }
    }

    // Logout functionality
    document.getElementById("logoutBtn").addEventListener("click", async () => {
      try {
        if (watchId) {
          navigator.geolocation.clearWatch(watchId);
        }
        await signOut(auth);
      } catch (err) {
        console.error("Logout error:", err);
      }
    });

    // Enter key for login/register
    document.addEventListener("keypress", (e) => {
      if (e.key === "Enter" && loginBox.style.display !== "none") {
        e.preventDefault();
        document.getElementById("loginBtn").click();
      }
    });

    // Authentication state observer
    let locationUpdateInterval = null;
    onAuthStateChanged(auth, (user) => {
      if (user) {
        loginBox.style.display = "none";
        userEmail = user.email;
        userName = user.displayName || user.email.split('@')[0];
        lastHistoryEntry = null;
        accountName.textContent = userName;
        accountEmail.textContent = userEmail;
        initMap(user.uid);
        sidebarNotifBar.innerHTML = `<span class="status-indicator"></span>Logged in as: ${userName}`;

        // Start periodic location notification updates
        if (locationUpdateInterval) clearInterval(locationUpdateInterval);
        locationUpdateInterval = setInterval(() => {
          refreshLocationNotifications();
        }, 300000); // 5 minutes
        // Also run immediately on login
        refreshLocationNotifications();
        updateLinkedDevicesNotifBar();
      } else {
        loginBox.style.display = "block";
        accountName.textContent = "-";
        accountEmail.textContent = "-";
        sidebarNotifBar.innerHTML = `<span class="status-indicator"></span>Please log in to start tracking`;
        if (map) {
          map.remove();
          map = null;
        }
        if (locationUpdateInterval) clearInterval(locationUpdateInterval);
        lastHistoryEntry = null;
        // Reset reminders/watchers state on logout to avoid carrying listeners to next user
        try {
          remindersWatcherAttached = false;
        } catch (e) {}
        try { watchedChildren.clear(); } catch(e){}
        try {
          Object.keys(reminderTimers).forEach(id => { clearTimeout(reminderTimers[id]); delete reminderTimers[id]; });
        } catch(e) {}
        try { document.getElementById('reminderList').innerHTML = ''; } catch(e){}
        remindersCache = [];
        if (reminderDateNotes) {
          reminderDateNotes.textContent = 'Select a date to see notes.';
        }
        if (reminderDatePicker) {
          reminderDatePicker.value = '';
        }
        try { hideReminderHUD(); } catch(e){}
        closeDashboard();
      }
    });

    // Initialize map and tracking
    function initMap(uid) {
      deviceId = uid;
      // Do NOT auto-request notification permission here to avoid browser blocking.
      // The user can explicitly enable notifications using the button in the top bar.
      
      // Create map centered on Cebu City
      map = L.map("map").setView([10.3103, 123.9494], 13);
      
      // Add tile layer
      L.tileLayer('https://maps.geoapify.com/v1/tile/osm-bright/{z}/{x}/{y}.png?apiKey=ce143278d50e455596672566ef35fb5b', {
        attribution: "¬© OpenStreetMap contributors ¬© Geoapify",
        maxZoom: 19
      }).addTo(map);

      // Store initial device data
      const deviceRef = ref(db, `devices/${deviceId}`);
      update(deviceRef, {
        email: userEmail,
        displayName: userName,
        uid: deviceId,
        lastSeen: serverTimestamp()
      }).catch(err => {
        console.error("Error initializing device record:", err);
      });

      // Start location tracking
      if (navigator.geolocation) {
        console.log('Starting geolocation watch for deviceId:', deviceId);
        notifBar.innerHTML = `<span class="status-indicator"></span>Starting location tracking...`;
        watchId = navigator.geolocation.watchPosition(
          (position) => {
            const { latitude, longitude, accuracy } = position.coords;
            console.log('Geolocation update:', latitude, longitude, 'deviceId:', deviceId);
            notifBar.innerHTML = `<span class="status-indicator"></span>Got location: ${latitude.toFixed(4)}, ${longitude.toFixed(4)} - Saving...`;
            
            const deviceRef = ref(db, `devices/${deviceId}`);
            const updates = {
              latitude,
              longitude,
              lastSeen: serverTimestamp(),
              email: userEmail,
              displayName: userName,
              uid: deviceId
            };
            if (typeof accuracy === "number") {
              updates.accuracy = accuracy;
            }

            console.log('Attempting to write location to:', `devices/${deviceId}`, updates);
            update(deviceRef, updates)
              .then(() => {
                console.log('Location update successful');
                notifBar.innerHTML = `<span class="status-indicator" style="background:#28a745"></span>Location saved successfully at ${new Date().toLocaleTimeString()}`;
                maybeRecordLocationHistory(latitude, longitude, accuracy, position.timestamp || Date.now());
              })
              .catch(error => {
              console.error("Error storing location:", error);
              notifBar.innerHTML = `<span class="status-indicator" style="background:#dc3545"></span>WRITE FAILED: ${error.code} - ${error.message}`;
              alert(`Location write failed!\nError: ${error.code}\nMessage: ${error.message}\n\nCheck Firebase rules allow: auth.uid === "${deviceId}"`);
            });
          },
          (error) => {
            console.error("Error tracking location:", error);
            const errorMsg = `Location Error: ${error.code} - ${error.message}`;
            notifBar.innerHTML = `<span class="status-indicator" style="background:#dc3545"></span>${errorMsg}`;
            alert(errorMsg + '\n\nMake sure you allowed location access in your browser!');
          },
          {
            enableHighAccuracy: true,
            maximumAge: 30000,
            timeout: 27000
          }
        );
      } else {
        notifBar.innerHTML = `<span class="status-indicator" style="background:#dc3545"></span>Geolocation not supported`;
        alert('Your browser does not support geolocation!');
      }

      // Listen for all devices - wait a moment for auth to fully propagate
      setTimeout(() => {
        console.log('Setting up devices listener with authenticated user');
        onValue(ref(db, "devices"), (snapshot) => {
          console.log('Devices snapshot received');
          const devicesData = snapshot.val();
          console.log('Raw devices data:', devicesData);
          console.log('Current deviceId:', deviceId);
          if (devicesData && devicesData[deviceId]) {
            console.log('My device data:', devicesData[deviceId]);
          } else {
            console.log('WARNING: My device not found in snapshot!');
          }
          updateDevicesList(snapshot);
        }, (error) => {
          console.error('Error reading devices:', error);
          notifBar.innerHTML = `<span class="status-indicator" style="background:#dc3545"></span>READ ERROR: ${error.code} - ${error.message}`;
        });
      }, 500);

      // Manage linked-device listeners and UI
      refreshLinkedDevices();
      // Load and watch reminders for this device
      loadReminders();
      watchReminders();
  }

  // Function to check if a linked device's location has changed significantly
    const lastNotifiedLocations = {};
    function checkLocationChange(deviceId, newLat, newLon, timestamp) {
      const lastLoc = lastNotifiedLocations[deviceId];
      if (!lastLoc || (timestamp && lastLoc.timestamp !== timestamp)) {
        // Calculate distance if we have a previous location
        if (lastLoc) {
          const distance = calculateDistance(
            lastLoc.lat, lastLoc.lon,
            newLat, newLon
          );
          
          // If moved more than 100 meters, notify
          if (distance > 0.1) {
            const deviceRef = ref(db, `devices/${deviceId}`);
            get(deviceRef).then(snapshot => {
              const device = snapshot.val();
              if (device) {
                const name = device.displayName || device.email || `Device ${deviceId.substring(0, 8)}`;
                notifBar.innerHTML = `<span class="status-indicator"></span>${name} has moved ${distance.toFixed(2)}km`;
              }
            });
          }
        }
        
        // Update last known location
        lastNotifiedLocations[deviceId] = {
          lat: newLat,
          lon: newLon,
          timestamp: timestamp
        };
      }
    }

    // Calculate distance between two points in kilometers
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Earth's radius in kilometers
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

  onValue(ref(db, "devices"), updateDevicesList);

    // Update devices list and map markers
    function updateDevicesList(snapshot) {
      const deviceList = document.getElementById("deviceList");
      deviceList.innerHTML = "";
      const devices = snapshot.val() || {};
      let currentDeviceSeen = false;
      const visibleMarkerIds = new Set();

      console.log('updateDevicesList called. Current deviceId:', deviceId, 'Devices:', Object.keys(devices));

      for (const id in devices) {
        const device = devices[id];
        if (!device) continue;

        const { latitude, longitude, email, displayName, lastSeen, accuracy, linkedTo } = device;
        const isCurrentUser = id === deviceId;
        const isLinkedDevice = linkedTo === deviceId;
        const isParentDevice = device.links && device.links[id];
        const hasLocation = typeof latitude === 'number' && typeof longitude === 'number';
        const timeDiff = lastSeen ? getTimeDifference(lastSeen) : 'Unknown';

        console.log('Processing device:', id, 'isCurrentUser:', isCurrentUser, 'hasLocation:', hasLocation, 'lat:', latitude, 'lon:', longitude);

        if (isCurrentUser || isLinkedDevice || isParentDevice) {
          if (isCurrentUser) {
            currentDeviceSeen = true;
            console.log('Found current user device. hasLocation:', hasLocation);
            if (userLocationPanel) {
              if (hasLocation) {
                userLocationPanel.classList.remove("hidden");
                userLocationCoords.textContent = `üìç ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                userLocationTime.textContent = `Last updated ${timeDiff}`;
                console.log('Updated user location panel with coordinates');
              } else {
                userLocationCoords.textContent = 'No location available yet';
                userLocationTime.textContent = '-';
                console.log('Current user has no location data');
              }
            }
          }

          if (hasLocation) {
            if (!markers[id]) {
              const markerColor = isCurrentUser ? '#0077ff' : (isLinkedDevice ? '#28a745' : '#666');
              const icon = L.divIcon({
                className: 'custom-div-icon',
                html: `<div style="background-color: ${markerColor}; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
              });

              markers[id] = L.marker([latitude, longitude], { icon })
                .addTo(map)
                .bindPopup(createPopupContent(id, device));
            } else {
              markers[id].setLatLng([latitude, longitude]);
              markers[id].setPopupContent(createPopupContent(id, device));
            }
            visibleMarkerIds.add(id);
          } else if (markers[id]) {
            markers[id].remove();
            delete markers[id];
          }

          if (!isCurrentUser) {
            const deviceItem = document.createElement("div");
            deviceItem.className = 'device-item';
            const locationHtml = hasLocation
              ? `üìç ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`
              : '<span style="color:#dc3545">No location available</span>';

            deviceItem.innerHTML = `
              <div class="device-info">
                <div class="device-id">
                  ${displayName || email || `Device ${id.substring(0, 8)}`}
                  ${isLinkedDevice ? '<span style="color:#28a745;font-size:12px;margin-left:5px;">(Linked)</span>' : ''}
                </div>
                <div class="device-coords">${locationHtml}</div>
                <div class="device-time">üïí ${timeDiff}</div>
              </div>
            `;

            if (isLinkedDevice) {
              const topBadge = document.createElement('div');
              topBadge.className = 'top-location-badge';
              topBadge.style.marginTop = '10px';
              topBadge.textContent = 'Loading top spot...';
              deviceItem.appendChild(topBadge);

              fetchTopLocationRanking(id, 1).then(ranking => {
                if (!deviceList.contains(deviceItem)) return;
                if (!ranking.length) {
                  topBadge.textContent = 'No visits recorded yet.';
                  return;
                }

                const top = ranking[0];
                const coordsLabel = `${top.lat.toFixed(4)}, ${top.lon.toFixed(4)}`;
                const recency = top.lastSeen ? getTimeDifference(top.lastSeen) : 'Unknown';
                topBadge.innerHTML = `<strong>Top spot</strong> ${coordsLabel}<br><span style="font-size:12px;color:#365a74;">${top.visits} visit${top.visits === 1 ? '' : 's'} ¬∑ Last seen ${recency}</span>`;
              });
            }

            deviceItem.addEventListener('click', () => {
              if (hasLocation && markers[id]) {
                map.setView([latitude, longitude], 16);
                markers[id].openPopup();
              }
              showDeviceDetails(id, device);
            });

            deviceList.appendChild(deviceItem);
          }
        }
      }

      // Always keep marker for current device if present
      if (markers[deviceId]) {
        visibleMarkerIds.add(deviceId);
      }

      Object.keys(markers).forEach(id => {
        if (!visibleMarkerIds.has(id) || !devices[id]) {
          markers[id].remove();
          delete markers[id];
        }
      });

      if (!currentDeviceSeen && userLocationCoords) {
        console.log('WARNING: Current device not seen in device list!');
        userLocationCoords.textContent = 'Waiting for device updates...';
        userLocationTime.textContent = '-';
        
        // Show debug info in notification bar
        notifBar.innerHTML = `<span class="status-indicator" style="background:#ffc107"></span>Device data not appearing in list. Check Firebase console for UID: ${deviceId}`;
      }

      if (!deviceList.hasChildNodes()) {
        deviceList.innerHTML = '<div style="padding:8px;color:#cfe9ff;">No devices to display yet.</div>';
      }
    }

    // Helper function to create popup content
    function createPopupContent(id, device) {
      const { latitude, longitude, email, displayName, lastSeen, accuracy, linkedTo } = device;
      const isLinkedDevice = linkedTo === deviceId;
      return `
        <strong>${displayName || email || 'Unknown User'}</strong><br>
        ${id === deviceId ? '(You)' : (isLinkedDevice ? '(Linked Device)' : '')}<br>
        Email: ${email}<br>
        Location: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}<br>
        ${accuracy ? `Accuracy: ${Math.round(accuracy)}m<br>` : ''}
        Last seen: ${lastSeen ? new Date(lastSeen).toLocaleString() : 'Unknown'}
      `;
    }

    // Show device details in dashboard
    function showDeviceDetails(id, device) {
      const { latitude, longitude, email, displayName, lastSeen, accuracy, linkedTo } = device;
      const isLinkedDevice = linkedTo === deviceId;
      const hasLocation = typeof latitude === 'number' && typeof longitude === 'number';

      openDashboard();
      activateSection("devices");

      const deviceDetails = document.getElementById("deviceDetails");
      deviceDetails.classList.remove("hidden");
      deviceDetails.innerHTML = `
  <div style="margin-top:20px; padding:18px; background:#f8f9fa; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.07); color:#0b2a4e;">
          <h4 style="margin-bottom:10px; color:#0077ff;">
            ${displayName || email || `Device ${id.substring(0, 8)}`}
            ${id === deviceId ? '<span style="color:#0077ff;font-size:12px;margin-left:5px;">(You)</span>' : 
              (isLinkedDevice ? '<span style="color:#28a745;font-size:12px;margin-left:5px;">(Linked)</span>' : '')}
          </h4>
          <div><b>Email:</b> ${email}</div>
          <div><b>Location:</b> ${hasLocation ? 
            `${latitude.toFixed(6)}, ${longitude.toFixed(6)}` : 
            '<span style="color:#b02a37">No location available</span>'}
          </div>
          <div><b>Accuracy:</b> ${accuracy ? Math.round(accuracy) + 'm' : 'Unknown'}</div>
          <div><b>Last seen:</b> ${lastSeen ? new Date(lastSeen).toLocaleString() : 'Unknown'}</div>
          ${hasLocation ? 
            `<div style="margin-top:10px; display:flex; gap:8px;">
              <button style="background:#0077ff; color:white; border:none; border-radius:6px; padding:8px 16px; font-weight:bold; cursor:pointer;" 
                      onclick="centerMapDevice('${id}')">Center Map</button>
              ${isLinkedDevice ? 
                `<button style="background:#28a745; color:white; border:none; border-radius:6px; padding:8px 16px; font-weight:bold; cursor:pointer;"
                        onclick="trackDevice('${id}')">Track Location</button>` : ''}
            </div>` : ''}
          <div style="margin-top:18px;">
            <div style="color:#0056cc;font-weight:bold;margin-bottom:6px;">Most visited spots</div>
            <div id="topLocations-${id}"></div>
          </div>
        </div>
      `;
      loadTopLocations(id);
    }

    // Center map on selected device
    window.centerMapDevice = function(id) {
      if (markers[id]) {
        map.setView(markers[id].getLatLng(), 16);
        markers[id].openPopup();
      }
    };

    // Track selected device (follow its location in real time)
    let trackedDeviceId = null;
    window.trackDevice = function(id) {
      trackedDeviceId = id;
      notifBar.innerHTML = `<span class="status-indicator"></span>Tracking ${id === deviceId ? 'yourself' : 'device'}...`;
    };

    // Update map view if tracking a device
    function updateTrackedDeviceView(data) {
      if (trackedDeviceId && data && data[trackedDeviceId] && markers[trackedDeviceId]) {
        const { latitude, longitude } = data[trackedDeviceId];
        map.setView([latitude, longitude], 16);
        markers[trackedDeviceId].openPopup();
      }
    }

    // Helper functions
    function showError(message) {
      errorMessage.textContent = message;
      setTimeout(() => {
        errorMessage.textContent = "";
      }, 5000);
    }

    function getTimeDifference(timestamp) {
      const now = new Date();
      const then = new Date(timestamp);
      const diffMs = now - then;
      const diffMins = Math.floor(diffMs / 60000);
      
      if (diffMins < 1) return "Just now";
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
      return `${Math.floor(diffMins / 1440)}d ago`;
    }

    // Function to check device location and notify if needed
    let lastLocationChecks = {};
    function checkDeviceLocation(deviceId, deviceData) {
      const now = Date.now();
      const lastCheck = lastLocationChecks[deviceId] || 0;
      
      // Check no more than once every 2 minutes
      if (now - lastCheck < 120000) return;
      
      lastLocationChecks[deviceId] = now;
      const { latitude, longitude, lastSeen, displayName, email } = deviceData;
      
      // Get current device's location for distance calculation
      get(ref(db, `devices/${deviceId}`)).then(snapshot => {
        const currentDevice = snapshot.val();
        if (currentDevice && currentDevice.latitude) {
          const distance = calculateDistance(
            currentDevice.latitude,
            currentDevice.longitude,
            latitude,
            longitude
          );

          const deviceLabel = displayName || email || `Device ${deviceId.substring(0,8)}`;
          
          // Notify if device is more than 1km away
          if (distance > 1) {
            sendLocationAlert(deviceLabel, distance);
          }
          
          // Update the notification bar
          notifBar.innerHTML = `<span class="status-indicator"></span>${deviceLabel} is ${distance.toFixed(2)}km away`;
          
          // Store this location check
          set(ref(db, `locationChecks/${deviceId}`), {
            timestamp: serverTimestamp(),
            distance: distance,
            latitude: latitude,
            longitude: longitude
          });
        }
      });
    }

    // Function to send a browser notification
    function sendLocationAlert(deviceLabel, distance) {
      if (!("Notification" in window)) return;
      
      if (Notification.permission === "granted") {
        new Notification("CheckPoint Location Alert", {
          body: `${deviceLabel} is ${distance.toFixed(2)}km away from you`,
          icon: "/favicon.ico"
        });
      } else if (Notification.permission !== "denied") {
        Notification.requestPermission().then(permission => {
          if (permission === "granted") {
            sendLocationAlert(deviceLabel, distance);
          }
        });
      }
    }

    // Function to refresh location notifications
    function refreshLocationNotifications() {
      const linksRef = ref(db, `links/${deviceId}`);
      get(linksRef).then(snapshot => {
        const links = snapshot.val() || {};
        
        Object.keys(links).forEach(childId => {
          get(ref(db, `devices/${childId}`)).then(deviceSnapshot => {
            const device = deviceSnapshot.val();
            if (device && device.latitude && device.longitude) {
              checkDeviceLocation(childId, device);
            }
          });
        });
        // After checking individual child locations, update the visible notification bar summary
        updateLinkedDevicesNotifBar();
      });
    }

    // Update the top notification bar with a compact summary of linked devices (runs every 5 minutes via existing scheduler)
    async function updateLinkedDevicesNotifBar() {
      if (!deviceId) return;
      try {
        const linksSnap = await get(ref(db, `links/${deviceId}`));
        const links = linksSnap.val() || {};
        const childIds = Object.keys(links);
        if (childIds.length === 0) {
          notifBar.innerHTML = `<span class="status-indicator"></span>No linked devices`; 
          return;
        }

        // Fetch each child's latest info in parallel
        const promises = childIds.map(id => get(ref(db, `devices/${id}`)).then(s => ({ id, data: s.val() })));
        const results = await Promise.all(promises);

        // Build a compact summary: Name (coords) ¬∑ lastSeen
        const parts = results.map(r => {
          const d = r.data || {};
          const name = d.displayName || d.email || `Device ${r.id.substring(0,8)}`;
          if (d.latitude && d.longitude) {
            const coords = `${d.latitude.toFixed(4)}, ${d.longitude.toFixed(4)}`;
            const last = d.lastSeen ? getTimeDifference(d.lastSeen) : 'Unknown';
            return `${name}: ${coords} ¬∑ ${last}`;
          }
          return `${name}: No location`; 
        }).slice(0,4); // show up to 4 devices

        notifBar.innerHTML = `<span class="status-indicator"></span>` + parts.join(' | ');
      } catch (err) {
        console.error('Error updating linked devices notif bar:', err);
      }
    }

    function maybeRecordLocationHistory(lat, lon, accuracy, timestampMs) {
      if (!deviceId) return;
      const safeTimestamp = typeof timestampMs === "number" ? timestampMs : Date.now();
      if (!shouldRecordHistory(lat, lon, safeTimestamp)) {
        return;
      }

      lastHistoryEntry = {
        lat,
        lon,
        timestamp: safeTimestamp
      };

      const entryId = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const payload = {
        latitude: lat,
        longitude: lon,
        recordedAt: serverTimestamp(),
        clientTimestamp: safeTimestamp
      };
      if (typeof accuracy === "number") {
        payload.accuracy = accuracy;
      }

      set(ref(db, `locationHistory/${deviceId}/${entryId}`), payload).catch(err => {
        console.error("Location history error:", err);
      });
    }

    function shouldRecordHistory(lat, lon, timestampMs) {
      if (!lastHistoryEntry) return true;
      const timeGap = Math.abs(timestampMs - lastHistoryEntry.timestamp || 0);
      if (timeGap >= HISTORY_MIN_INTERVAL_MS) return true;

      const distanceKm = calculateDistance(lastHistoryEntry.lat, lastHistoryEntry.lon, lat, lon);
      return distanceKm >= HISTORY_MIN_DISTANCE_KM;
    }

    async function fetchTopLocationRanking(targetDeviceId, limit = 5) {
      try {
        const historySnap = await get(query(ref(db, `locationHistory/${targetDeviceId}`), limitToLast(500)));
        const historyData = historySnap.val();
        if (!historyData) return [];

        const buckets = new Map();
        Object.values(historyData).forEach(entry => {
          if (!entry || typeof entry.latitude !== "number" || typeof entry.longitude !== "number") return;
          const key = `${entry.latitude.toFixed(3)},${entry.longitude.toFixed(3)}`;
          const data = buckets.get(key) || {
            count: 0,
            latSum: 0,
            lonSum: 0,
            lastSeen: 0
          };
          data.count += 1;
          data.latSum += entry.latitude;
          data.lonSum += entry.longitude;
          const recorded = typeof entry.recordedAt === "number" ? entry.recordedAt : (typeof entry.clientTimestamp === "number" ? entry.clientTimestamp : 0);
          if (recorded > data.lastSeen) {
            data.lastSeen = recorded;
          }
          buckets.set(key, data);
        });

        const ranking = Array.from(buckets.values())
          .map(item => ({
            visits: item.count,
            lat: item.latSum / item.count,
            lon: item.lonSum / item.count,
            lastSeen: item.lastSeen
          }))
          .filter(item => !Number.isNaN(item.lat) && !Number.isNaN(item.lon))
          .sort((a, b) => {
            if (b.visits !== a.visits) return b.visits - a.visits;
            return (b.lastSeen || 0) - (a.lastSeen || 0);
          })
          .slice(0, limit);

        return ranking;
      } catch (err) {
        console.error('Top locations fetch error:', err);
        return [];
      }
    }

    async function loadTopLocations(targetDeviceId) {
      const container = document.getElementById(`topLocations-${targetDeviceId}`);
      if (!container) return;
      container.innerHTML = '<div style="color:#0b2a4e;">Loading top locations...</div>';

      try {
        const ranking = await fetchTopLocationRanking(targetDeviceId, 5);
        if (!ranking.length) {
          container.innerHTML = '<div class="top-location-badge">No visits recorded yet.</div>';
          return;
        }

        const list = document.createElement('div');
        ranking.forEach((item, index) => {
          const positionLabel = `${item.lat.toFixed(4)}, ${item.lon.toFixed(4)}`;
          const recency = item.lastSeen ? getTimeDifference(item.lastSeen) : 'Unknown';

          const entry = document.createElement('div');
          entry.className = 'top-location-badge';
          entry.innerHTML = `
            <strong>#${index + 1}</strong> ${positionLabel}<br>
            <span style="font-size:12px;color:#365a74;">${item.visits} visit${item.visits === 1 ? '' : 's'} ¬∑ Last seen ${recency}</span>
          `;
          list.appendChild(entry);
        });

        container.innerHTML = '';
        container.appendChild(list);
      } catch (err) {
        console.error('Top locations error:', err);
        container.innerHTML = '<div style="color:#dc3545;">Unable to load location stats.</div>';
      }
    }

    async function requestAiSummary(payload, apiKey) {
      if (AI_SUMMARY_ENDPOINT) {
        const proxyHeaders = {
          "Content-Type": "application/json"
        };
        const proxyResponse = await fetch(AI_SUMMARY_ENDPOINT, {
          method: "POST",
          headers: proxyHeaders,
          body: JSON.stringify(payload)
        });

        if (!proxyResponse.ok) {
          let message = `Proxy HTTP ${proxyResponse.status}`;
          try {
            const errJson = await proxyResponse.json();
            if (errJson?.error) {
              message = errJson.error;
            } else if (errJson?.message) {
              message = errJson.message;
            }
          } catch (err) {}
          throw new Error(message);
        }

        const proxyJson = await proxyResponse.json();
        const proxySummary = (proxyJson && (proxyJson.summary || proxyJson.result || proxyJson.message)) || "";
        if (typeof proxySummary !== "string" || !proxySummary.trim()) {
          throw new Error("Proxy returned no summary text.");
        }
        return proxySummary.trim();
      }

      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          temperature: 0.4,
          max_tokens: 220,
          messages: [
            {
              role: "system",
              content: "You turn raw GPS device readings into concise caregiver updates. Keep the output under four sentences and do not invent information."
            },
            {
              role: "user",
              content: payload.prompt
            }
          ]
        })
      });

      if (!response.ok) {
        let message = `HTTP ${response.status}`;
        try {
          const errJson = await response.json();
          if (errJson?.error?.message) {
            message = errJson.error.message;
          }
        } catch (err) {}
        throw new Error(message);
      }

      const directPayload = await response.json();
      const summaryText = directPayload?.choices?.[0]?.message?.content?.trim();
      if (!summaryText) {
        throw new Error("No summary returned by the AI service.");
      }
      return summaryText;
    }

    function setupAiSummaryMode() {
      if (AI_SUMMARY_ENDPOINT) {
        if (aiKeyControls) {
          aiKeyControls.style.display = "none";
        }
        if (aiSummaryHint) {
          aiSummaryHint.textContent = "AI summaries run through a secure Worker proxy. No API key is stored in this browser.";
        }
        if (aiSummaryStatus && (!aiSummaryStatus.textContent || aiSummaryStatus.textContent === "AI summary is idle.")) {
          aiSummaryStatus.textContent = "Ready to use secure AI summarizer.";
        }
      } else {
        restoreAiKeyFromStorage();
        if (aiSummaryHint) {
          aiSummaryHint.textContent = "Keys are stored in this browser's local storage. Avoid using shared devices.";
        }
      }
    }

    function getStoredAiKey() {
      try {
        return localStorage.getItem(AI_KEY_STORAGE) || "";
      } catch (err) {
        console.warn("Unable to read AI key from storage", err);
        return "";
      }
    }

    function setStoredAiKey(value) {
      try {
        localStorage.setItem(AI_KEY_STORAGE, value);
        return true;
      } catch (err) {
        console.warn("Unable to store AI key", err);
        return false;
      }
    }

    function clearStoredAiKey() {
      try {
        localStorage.removeItem(AI_KEY_STORAGE);
        return true;
      } catch (err) {
        console.warn("Unable to clear AI key", err);
        return false;
      }
    }

    function restoreAiKeyFromStorage() {
      if (!aiApiKeyInput) return;
      const stored = getStoredAiKey();
      if (stored) {
        aiApiKeyInput.value = stored;
      }
    }

    function getActiveAiApiKey() {
      if (!aiApiKeyInput) return "";
      const direct = aiApiKeyInput.value.trim();
      if (direct) return direct;
      const stored = getStoredAiKey().trim();
      if (stored) {
        aiApiKeyInput.value = stored;
        return stored;
      }
      return "";
    }

    async function generateAiSummary() {
      if (!generateAiSummaryBtn || !aiSummaryStatus || !aiSummaryOutput) return;
      if (!deviceId) {
        aiSummaryStatus.textContent = "Log in to generate a summary.";
        aiSummaryOutput.textContent = "Authenticate first, then try again.";
        return;
      }

      const useProxy = Boolean(AI_SUMMARY_ENDPOINT);
      let apiKey = "";
      if (!useProxy) {
        apiKey = getActiveAiApiKey();
        if (!apiKey) {
          aiSummaryStatus.textContent = "Enter your OpenAI API key first.";
          aiSummaryOutput.textContent = "Paste a key above or save one locally.";
          return;
        }
      }

      const originalLabel = generateAiSummaryBtn.textContent;
      generateAiSummaryBtn.disabled = true;
      generateAiSummaryBtn.textContent = "Summarizing...";
      aiSummaryStatus.textContent = useProxy ? "Collecting device data for proxy..." : "Collecting latest device locations...";
      aiSummaryOutput.textContent = "";

      try {
        const linksSnap = await get(ref(db, `links/${deviceId}`));
        const links = linksSnap.val() || {};
        const childIds = Object.keys(links);
        const targetIds = [deviceId, ...childIds];

        if (targetIds.length === 0) {
          aiSummaryStatus.textContent = "No linked devices available yet.";
          aiSummaryOutput.textContent = "Link a device to generate insights.";
          return;
        }

        const records = await Promise.all(targetIds.map(async (id) => {
          const snap = await get(ref(db, `devices/${id}`));
          return { id, data: snap.val() };
        }));

        const hasAnyLocation = records.some(r => r.data && typeof r.data.latitude === "number" && typeof r.data.longitude === "number");
        if (!hasAnyLocation) {
          aiSummaryStatus.textContent = "No coordinates available yet.";
          aiSummaryOutput.textContent = "Wait for devices to report their position, then retry.";
          return;
        }

        const now = new Date();
        const parentEntry = records.find(r => r.id === deviceId);
        const parentCoords = parentEntry && parentEntry.data && typeof parentEntry.data.latitude === "number" && typeof parentEntry.data.longitude === "number"
          ? { lat: parentEntry.data.latitude, lon: parentEntry.data.longitude }
          : null;

        const lines = records.map((r) => {
          const data = r.data || {};
          const isParent = r.id === deviceId;
          const label = isParent ? "Parent device" : (data.displayName || data.email || `Device ${r.id.substring(0, 8)}`);
          const hasLocation = typeof data.latitude === "number" && typeof data.longitude === "number";
          const coordsText = hasLocation ? `${data.latitude.toFixed(4)}, ${data.longitude.toFixed(4)}` : "no coordinates";
          const recency = data.lastSeen ? getTimeDifference(data.lastSeen) : "no timestamp";
          let distanceText = "distance from parent unknown";
          if (isParent && hasLocation) {
            distanceText = "current device";
          } else if (parentCoords && hasLocation) {
            const distKm = calculateDistance(parentCoords.lat, parentCoords.lon, data.latitude, data.longitude);
            distanceText = `distance from parent ${distKm.toFixed(2)} km`;
          }
          return `${label} | coords: ${coordsText} | seen: ${recency} | ${distanceText}`;
        });

        const limitedLines = lines.slice(0, 12);

        const prompt = `Summarize the following tracker snapshot for a caregiver in three short sentences. Mention who is together or far apart (over 0.5 km), and flag stale updates if "no timestamp" or older than an hour. Stay calm and factual. Current time: ${now.toLocaleString()}.

${limitedLines.join("\n")}`;

        const summaryText = await requestAiSummary({
          prompt,
          lines: limitedLines,
          currentTime: now.toISOString()
        }, apiKey);
        aiSummaryOutput.textContent = summaryText;
        aiSummaryStatus.textContent = `Last updated ${new Date().toLocaleTimeString()}.`;
      } catch (err) {
        console.error("AI summary error", err);
        aiSummaryStatus.textContent = `AI error: ${err.message}`;
        if (!aiSummaryOutput.textContent) {
          aiSummaryOutput.textContent = "Unable to generate summary.";
        }
      } finally {
        generateAiSummaryBtn.disabled = false;
        generateAiSummaryBtn.textContent = originalLabel;
      }
    }

    // Request permissions on load
    window.addEventListener('load', () => {
      if (navigator.geolocation) {
        navigator.permissions.query({name: 'geolocation'}).then((result) => {
          console.log('Geolocation permission:', result.state);
        });
      }
      // Do not call Notification.requestPermission() automatically here ‚Äî modern browsers
      // on insecure origins or without a user gesture will block the prompt. Provide an
      // explicit button instead.
      updateNotificationUI();
    });

    // Notification UI elements
    const enableNotifBtn = document.getElementById('enableNotifBtn');
    const notifText = document.getElementById('notifText');

    function updateNotificationUI() {
      if (!('Notification' in window)) {
        enableNotifBtn.style.display = 'none';
        notifText.textContent = 'Notifications not supported in this browser.';
        return;
      }

      if (Notification.permission === 'granted') {
        enableNotifBtn.style.display = 'none';
        notifText.textContent = 'Notifications enabled.';
      } else if (Notification.permission === 'denied') {
        enableNotifBtn.style.display = 'inline-block';
        notifText.textContent = 'Notifications are blocked. Check browser settings to allow.';
      } else {
        enableNotifBtn.style.display = 'inline-block';
        notifText.textContent = 'Click to enable notifications for alerts.';
      }
    }

    enableNotifBtn.addEventListener('click', async () => {
      if (!('Notification' in window)) return;
      try {
        const permission = await Notification.requestPermission();
        if (permission === 'granted') {
          notifText.textContent = 'Notifications enabled.';
          enableNotifBtn.style.display = 'none';
          // Optionally show a test notification
          new Notification('Checkpoint Tracker', { body: 'Notifications enabled.' });
        } else if (permission === 'denied') {
          notifText.textContent = 'Notifications blocked. Open browser settings to allow.';
        } else {
          notifText.textContent = 'Notification permission dismissed.';
        }
      } catch (err) {
        console.error('Notification request failed:', err);
        notifText.textContent = 'Unable to request notification permission.';
      }
    });

    // --- Reminders feature ---
    const addReminderBtn = document.getElementById('addReminderBtn');
    const reminderNoteInput = document.getElementById('reminderNote');
    const reminderTimeInput = document.getElementById('reminderTime');
    const reminderMsg = document.getElementById('reminderMsg');
    const reminderList = document.getElementById('reminderList');

    // In-memory timers for scheduled reminders
    const reminderTimers = {};

    addReminderBtn.addEventListener('click', async () => {
      const note = reminderNoteInput.value.trim();
      const timeStr = reminderTimeInput.value;
      if (!note || !timeStr) {
        reminderMsg.textContent = 'Please enter a note and a time.';
        return;
      }

      const when = new Date(timeStr).getTime();
      if (isNaN(when) || when <= Date.now()) {
        reminderMsg.textContent = 'Please choose a future date/time.';
        return;
      }

      addReminderBtn.disabled = true;
      addReminderBtn.textContent = 'Adding...';

      try {
        // Create a new reminder in Firebase
        const newId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        await set(ref(db, `reminders/${deviceId}/${newId}`), {
          id: newId,
          note,
          time: when,
          createdAt: serverTimestamp()
        });

  reminderNoteInput.value = '';
  reminderTimeInput.value = '';
  reminderMsg.textContent = 'Reminder saved.'; // watchReminders onValue will refresh the list
      } catch (err) {
        reminderMsg.textContent = 'Error saving reminder: ' + err.message;
      }

      addReminderBtn.disabled = false;
      addReminderBtn.textContent = 'Add Reminder';
    });

    if (reminderDatePicker) {
      reminderDatePicker.addEventListener('change', () => {
        updateReminderDateNotes();
      });
    }

    const scheduledReminderIds = new Set();
    async function loadReminders() {
      // Clear existing UI and timers first (defensive)
      reminderList.innerHTML = '';
      if (!deviceId) return;
      // Clear previously scheduled timers to avoid duplicates
      Object.keys(reminderTimers).forEach(id => {
        try { clearTimeout(reminderTimers[id]); } catch(e){}
        delete reminderTimers[id];
      });
      scheduledReminderIds.clear();
      try {
        const snap = await get(ref(db, `reminders/${deviceId}`));
        const data = snap.val() || {};
        const entries = Object.values(data).sort((a,b) => a.time - b.time);

        remindersCache = entries;
        renderReminderList(entries);

        if (!entries.length) {
          reminderList.innerHTML = '<div style="padding:8px;color:#cfe9ff;">No reminders</div>';
          if (reminderDateNotes) {
            reminderDateNotes.textContent = 'No reminders scheduled yet.';
          }
          return;
        }

        entries.forEach(r => {
          // Ensure not scheduling duplicate timers for same id
          if (reminderTimers[r.id]) {
            clearTimeout(reminderTimers[r.id]);
            delete reminderTimers[r.id];
          }
          scheduleReminder(r);
        });

        updateReminderDateNotes();
      } catch (err) {
        reminderList.innerHTML = '<div style="padding:8px;color:#ffcdd2;">Error loading reminders</div>';
        console.error('Error loading reminders', err);
      }
    }

    function renderReminderList(entries) {
      if (!reminderList) return;
      reminderList.innerHTML = '';

      if (!entries.length) {
        reminderList.innerHTML = '<div style="padding:8px;color:#cfe9ff;">No reminders</div>';
        return;
      }

      entries.forEach(r => {
        const when = new Date(r.time);
        const whenLabel = Number.isNaN(when.getTime()) ? 'No time set' : when.toLocaleString();
        const item = document.createElement('div');
        item.className = 'reminder-item';
        item.setAttribute('data-reminder-id', r.id);
        item.innerHTML = `
          <div style="font-weight:600;color:#e0f7fa;">${r.note}</div>
          <div style="font-size:12px;color:#cfe9ff;">${whenLabel}</div>
        `;

        const btnRow = document.createElement('div');
        btnRow.style.marginTop = '6px';
        const del = document.createElement('button');
        del.textContent = 'Delete';
        del.style.background = '#dc3545';
        del.style.color = 'white';
        del.style.border = 'none';
        del.style.borderRadius = '6px';
        del.style.padding = '6px 8px';
        del.style.cursor = 'pointer';
        del.onclick = () => deleteReminder(r.id);

        btnRow.appendChild(del);
        item.appendChild(btnRow);
        reminderList.appendChild(item);
      });
    }

    function updateReminderDateNotes() {
      if (!reminderDateNotes) return;
      if (!remindersCache.length) {
        reminderDateNotes.textContent = 'No reminders scheduled yet.';
        return;
      }

      if (!reminderDatePicker || !reminderDatePicker.value) {
        reminderDateNotes.textContent = 'Select a date to see notes.';
        return;
      }

      const selected = new Date(reminderDatePicker.value);
      if (Number.isNaN(selected.getTime())) {
        reminderDateNotes.textContent = 'Invalid date selected.';
        return;
      }

      const start = new Date(selected);
      start.setHours(0, 0, 0, 0);
      const end = new Date(start);
      end.setHours(23, 59, 59, 999);

      const matches = remindersCache.filter(r => {
        const when = new Date(r.time);
        return when >= start && when <= end;
      });

      if (!matches.length) {
        reminderDateNotes.textContent = 'No reminders scheduled for this day.';
        return;
      }

      const lines = matches.map(r => {
        const when = new Date(r.time);
        const timeLabel = Number.isNaN(when.getTime()) ? '--:--' : when.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        return `‚Ä¢ ${timeLabel} - ${r.note}`;
      });
      reminderDateNotes.textContent = lines.join('\n');
    }

    function scheduleReminder(r) {
      // Clear existing timer
      if (reminderTimers[r.id]) {
        clearTimeout(reminderTimers[r.id]);
      }

      const delay = r.time - Date.now();
      if (delay <= 0) return; // past due

      reminderTimers[r.id] = setTimeout(async () => {
        // Show notification if permitted, otherwise update notifBar
        const label = r.note || 'Reminder';
        // 1) Show in-app HUD + ping
        showReminderHUD(r);

        // 2) Browser notification if allowed (attach onclose to remove reminder when user closes)
        if ('Notification' in window && Notification.permission === 'granted') {
          try {
            const n = new Notification('Reminder', { body: label });
            // When the notification is closed by the user, delete the reminder
            n.onclose = () => {
              try { deleteReminder(r.id); } catch (e) { console.error('Failed to delete reminder on notification close', e); }
            };
            // Optional: focus window on click
            n.onclick = () => { try { window.focus(); } catch (e){} };
          } catch (e) {
            console.error('Notification error', e);
            notifBar.innerHTML = `<span class="status-indicator"></span>Reminder: ${label}`;
          }
        } else {
          // Fallback visual update
          notifBar.innerHTML = `<span class="status-indicator"></span>Reminder: ${label}`;
        }
      }, delay);
    }

    // Reminder HUD + sound
    const reminderHUD = document.getElementById('reminderHUD');
    const reminderHUDText = document.getElementById('reminderHUDText');
    const snoozeBtn = document.getElementById('snoozeBtn');
    const dismissBtn = document.getElementById('dismissBtn');
    let currentReminder = null;

    function playPing() {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(880, ctx.currentTime);
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1.0);
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + 1.0);
      } catch (e) {
        console.warn('Audio ping failed', e);
      }
    }

    function showReminderHUD(r) {
      currentReminder = r;
      reminderHUDText.textContent = r.note || 'Reminder';
      reminderHUD.style.display = 'block';
      // ensure it's visible even if the page is scrolled
      reminderHUD.scrollIntoView({ block: 'center' });
      playPing();
    }

    function hideReminderHUD() {
      reminderHUD.style.display = 'none';
      currentReminder = null;
    }

    // Snooze: reschedule current for +5 minutes
    snoozeBtn.addEventListener('click', async () => {
      if (!currentReminder) return;
      const newTime = Date.now() + 5 * 60 * 1000;
      try {
        await update(ref(db, `reminders/${deviceId}/${currentReminder.id}`), { time: newTime, fired: false });
        hideReminderHUD();
        loadReminders();
      } catch (e) {
        console.error('Snooze failed', e);
      }
    });

    // Dismiss: delete the reminder and hide UI
    dismissBtn.addEventListener('click', async () => {
      if (!currentReminder) return;
      try {
        await deleteReminder(currentReminder.id);
        hideReminderHUD();
      } catch (e) {
        console.error('Dismiss failed', e);
      }
    });

    async function deleteReminder(id) {
      if (!deviceId) return;
      try {
        await set(ref(db, `reminders/${deviceId}/${id}`), null);
        if (reminderTimers[id]) {
          clearTimeout(reminderTimers[id]);
          delete reminderTimers[id];
        }
        loadReminders();
      } catch (err) {
        console.error('Delete reminder error', err);
      }
    }

    // Listen for remote changes (adds/deletes) so UI stays in sync
    let remindersWatcherAttached = false;
    let remindersReloadTimer = null;
    function watchReminders() {
      if (!deviceId || remindersWatcherAttached) return;
      const rRef = ref(db, `reminders/${deviceId}`);
      onValue(rRef, (snap) => {
        // Debounce rapid DB events (some updates may fire multiple times)
        if (remindersReloadTimer) clearTimeout(remindersReloadTimer);
        remindersReloadTimer = setTimeout(() => {
          loadReminders();
        }, 150);
      });
      remindersWatcherAttached = true;
    }

    // Call loadReminders/watch when user logs in or when deviceId set
    // We'll call these after initMap completes and deviceId is assigned.
  </script>
  <script>
    // Register service worker for PWA (only on secure contexts / localhost)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        // Only register when on https or on localhost
        const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        if (location.protocol === 'https:' || isLocal) {
          navigator.serviceWorker.register('/service-worker.js').then(reg => {
            console.log('Service worker registered:', reg.scope);
          }).catch(err => {
            console.warn('Service worker registration failed:', err);
          });
        } else {
          console.log('Service worker not registered: insecure context');
        }
      });
    }
  </script>
</body>
</html>
